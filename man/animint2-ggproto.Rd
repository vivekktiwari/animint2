% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa-.r, R/geom-.r, R/annotation-custom.r,
%   R/annotation-logticks.r, R/geom-polygon.r, R/geom-map.r, R/annotation-map.r,
%   R/geom-raster.r, R/annotation-raster.r, R/coord-.r, R/coord-cartesian-.r,
%   R/coord-fixed.r, R/coord-flip.r, R/coord-map.r, R/coord-polar.r,
%   R/coord-quickmap.R, R/coord-transform.r, R/stat-.r, R/geom-abline.r,
%   R/geom-rect.r, R/geom-bar.r, R/geom-blank.r, R/geom-boxplot.r,
%   R/geom-path.r, R/geom-contour.r, R/geom-crossbar.r, R/geom-segment.r,
%   R/geom-curve.r, R/geom-ribbon.r, R/geom-density.r, R/geom-density2d.r,
%   R/geom-dotplot.r, R/geom-errorbar.r, R/geom-errorbarh.r, R/geom-hex.r,
%   R/geom-hline.r, R/geom-label.R, R/geom-linerange.r, R/geom-point.r,
%   R/geom-pointrange.r, R/geom-quantile.r, R/geom-rug.r, R/geom-smooth.r,
%   R/geom-spoke.r, R/geom-text.r, R/geom-tile.r, R/geom-violin.r,
%   R/geom-vline.r, R/position-.r, R/position-dodge.r, R/position-fill.r,
%   R/position-identity.r, R/position-jitter.r, R/position-jitterdodge.R,
%   R/position-nudge.R, R/position-stack.r, R/scale-.r, R/scale-continuous.r,
%   R/scale-date.r, R/scale-discrete-.r, R/scale-identity.r, R/scales-.r,
%   R/stat-bin.r, R/stat-bin2d.r, R/stat-bindot.r, R/stat-binhex.r,
%   R/stat-boxplot.r, R/stat-contour.r, R/stat-count.r, R/stat-density-2d.r,
%   R/stat-density.r, R/stat-ecdf.r, R/stat-ellipse.R, R/stat-function.r,
%   R/stat-identity.r, R/stat-qq.r, R/stat-quantile.r, R/stat-smooth.r,
%   R/stat-sum.r, R/stat-summary-2d.r, R/stat-summary-bin.R,
%   R/stat-summary-hex.r, R/stat-summary.r, R/stat-unique.r, R/stat-ydensity.r,
%   R/z_geoms.R
\docType{data}
\name{animint2-ggproto}
\alias{animint2-ggproto}
\alias{a_Geom}
\alias{a_GeomCustomAnn}
\alias{a_GeomLogticks}
\alias{a_GeomPolygon}
\alias{a_GeomMap}
\alias{a_GeomAnnotationMap}
\alias{a_GeomRaster}
\alias{a_GeomRasterAnn}
\alias{a_Coord}
\alias{a_CoordCartesian}
\alias{a_CoordFixed}
\alias{a_CoordFlip}
\alias{a_CoordMap}
\alias{a_CoordPolar}
\alias{a_CoordQuickmap}
\alias{a_CoordTrans}
\alias{a_Stat}
\alias{a_GeomAbline}
\alias{a_GeomRect}
\alias{a_GeomBar}
\alias{a_GeomBlank}
\alias{a_GeomBoxplot}
\alias{a_GeomPath}
\alias{a_GeomLine}
\alias{a_GeomStep}
\alias{a_GeomContour}
\alias{a_GeomCrossbar}
\alias{a_GeomSegment}
\alias{a_GeomCurve}
\alias{a_GeomRibbon}
\alias{a_GeomArea}
\alias{a_GeomDensity}
\alias{a_GeomDensity2d}
\alias{a_GeomDotplot}
\alias{a_GeomErrorbar}
\alias{a_GeomErrorbarh}
\alias{a_GeomHex}
\alias{a_GeomHline}
\alias{a_GeomLabel}
\alias{a_GeomLinerange}
\alias{a_GeomPoint}
\alias{a_GeomPointrange}
\alias{a_GeomQuantile}
\alias{a_GeomRug}
\alias{a_GeomSmooth}
\alias{a_GeomSpoke}
\alias{a_GeomText}
\alias{a_GeomTile}
\alias{a_GeomViolin}
\alias{a_GeomVline}
\alias{a_Position}
\alias{a_PositionDodge}
\alias{a_PositionFill}
\alias{a_PositionIdentity}
\alias{a_PositionJitter}
\alias{a_PositionJitterdodge}
\alias{a_PositionNudge}
\alias{a_PositionStack}
\alias{a_Scale}
\alias{a_ScaleContinuous}
\alias{a_ScaleDiscrete}
\alias{a_ScaleContinuousPosition}
\alias{a_ScaleContinuousDatetime}
\alias{a_ScaleContinuousDate}
\alias{a_ScaleDiscretePosition}
\alias{a_ScaleDiscreteIdentity}
\alias{a_ScaleContinuousIdentity}
\alias{a_ScalesList}
\alias{a_StatBin}
\alias{a_StatBin2d}
\alias{a_StatBindot}
\alias{a_StatBinhex}
\alias{a_StatBoxplot}
\alias{a_StatContour}
\alias{a_StatCount}
\alias{a_StatDensity2d}
\alias{a_StatDensity}
\alias{a_StatEcdf}
\alias{a_StatEllipse}
\alias{a_StatFunction}
\alias{a_StatIdentity}
\alias{a_StatQq}
\alias{a_StatQuantile}
\alias{a_StatSmooth}
\alias{a_StatSum}
\alias{a_StatSummary2d}
\alias{a_StatSummaryBin}
\alias{a_StatSummaryHex}
\alias{a_StatSummary}
\alias{a_StatUnique}
\alias{a_StatYdensity}
\alias{a_GeomTallRect}
\alias{a_GeomWideRect}
\title{Base ggproto classes for animint2}
\description{
If you are creating a new geom, stat, position, or scale in another package,
you'll need to extend from \code{animint2::a_Geom}, \code{animint2::a_Stat},
\code{animint2::a_Position}, or \code{animint2::a_Scale}.
}
\section{a_Geoms}{


All \code{a_geom_*} functions (like \code{a_geom_point}) return a layer that
contains a \code{a_Geom*} object (like \code{a_GeomPoint}). The \code{a_Geom*}
object is responsible for rendering the data in the plot.

Each of the \code{a_Geom*} objects is a \code{\link{a_ggproto}} object, descended
from the top-level \code{a_Geom}, and each implements various methods and
fields. To create a new type of Geom object, you typically will want to
implement one or more of the following:

Compared to \code{a_Stat} and \code{a_Position}, \code{a_Geom} is a little
different because the execution of the setup and compute functions is
split up. \code{setup_data} runs before position adjustments, and
\code{draw_layer} is not run until render time,  much later. This
means there is no \code{setup_params} because it's hard to communicate
the changes.

\itemize{
  \item Override either \code{draw_panel(self, data, panel_scales, a_coord)} or
    \code{draw_group(self, data, panel_scales, a_coord)}. \code{draw_panel} is
    called once per panel, \code{draw_group} is called once per group.

    Use \code{draw_panel} if each row in the data represents a
    single element. Use \code{draw_group} if each group represents
    an element (e.g. a smooth, a violin).

    \code{data} is a data frame of scaled aesthetics. \code{panel_scales}
    is a list containing information about the scales in the current
    panel. \code{a_coord} is a coordinate specification. You'll
    need to call \code{a_coord$transform(data, panel_scales)} to work
    with non-Cartesian coords. To work with non-linear coordinate systems,
    you typically need to convert into a primitive geom (e.g. point, path
    or polygon), and then pass on to the corresponding draw method
    for munching.

    Must return a grob. Use \code{\link{a_zeroGrob}} if there's nothing to
    draw.
  \item \code{draw_key}: Renders a single legend key.
  \item \code{required_aes}: A character vector of aesthetics needed to
    render the geom.
  \item \code{default_aes}: A list (generated by \code{\link{a_aes}()} of
    default values for aesthetics.
  \item \code{reparameterise}: Converts width and height to xmin and xmax,
    and ymin and ymax values. It can potentially set other values as well.
}
}

\section{a_Coordinate systems}{


All \code{a_coord_*} functions (like \code{a_coord_trans}) return a \code{a_Coord*}
object (like \code{a_CoordTrans}). The \code{a_Coord*} object is responsible for
adjusting the position of overlapping geoms.

The way that the \code{a_coord_*} functions work is slightly different from the
\code{a_geom_*} and \code{a_stat_*} functions, because a \code{a_coord_*} function
actually "instantiates" the \code{a_Coord*} object by creating a descendant,
and returns that.

Each of the \code{a_Coord*} objects is a \code{\link{a_ggproto}} object,
descended from the top-level \code{a_Coord}.  To create a new type of Coord
object, you typically will want to implement one or more of the following:

\itemize{
  \item \code{aspect}: Returns the desired aspect ratio for the plot.
  \item \code{a_labels}: Returns a list containing labels for x and y.
  \item \code{render_fg}: Renders foreground elements.
  \item \code{render_bg}: Renders background elements.
  \item \code{render_axis_h}: Renders the horizontal axis.
  \item \code{render_axis_v}: Renders the vertical axis.
  \item \code{range}: Returns the x and y ranges
  \item \code{train}: Return the trained scale ranges.
  \item \code{transform}: Transforms x and y coordinates.
  \item \code{distance}: Calculates distance.
  \item \code{is_linear}: Returns \code{TRUE} if the coordinate system is
    linear; \code{FALSE} otherwise.
}
}

\section{a_Stats}{


All \code{a_stat_*} functions (like \code{a_stat_bin}) return a layer that
contains a \code{a_Stat*} object (like \code{a_StatBin}). The \code{a_Stat*}
object is responsible for rendering the data in the plot.

Each of the \code{a_Stat*} objects is a \code{\link{a_ggproto}} object, descended
from the top-level \code{a_Stat}, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
implement one or more of the following:

\itemize{
  \item Override one of :
    \code{compute_layer(self, data, scales, ...)},
    \code{compute_panel(self, data, scales, ...)}, or
    \code{compute_group(self, data, scales, ...)}.

    \code{compute_layer()} is called once per layer, \code{compute_panel_()}
    is called once per panel, and \code{compute_group()} is called once per
    group. All must return a data frame.

    It's usually best to start by overriding \code{compute_group}: if
    you find substantial performance optimisations, override higher up.
    You'll need to read the source code of the default methods to see
    what else you should be doing.

    \code{data} is a data frame containing the variables named according
    to the aesthetics that they're mapped to. \code{scales} is a list
    containing the \code{x} and \code{y} scales. There functions are called
    before the facets are trained, so they are global scales, not local
    to the individual panels.\code{...} contains the parameters returned by
    \code{setup_params()}.
  \item \code{setup_params(data, params)}: called once for each layer.
     Used to setup defaults that need to complete dataset, and to inform
     the user of important choices. Should return list of parameters.
  \item \code{setup_data(data, params)}: called once for each layer,
     after \code{setp_params()}. Should return modified \code{data}.
     Default methods removes all rows containing a missing value in
     required aesthetics (with a warning if \code{!na.rm}).
  \item \code{required_aes}: A character vector of aesthetics needed to
    render the geom.
  \item \code{default_aes}: A list (generated by \code{\link{a_aes}()} of
    default values for aesthetics.
}
}

\section{a_Positions}{


All \code{a_position_*} functions (like \code{a_position_dodge}) return a
\code{a_Position*} object (like \code{a_PositionDodge}). The \code{a_Position*}
object is responsible for adjusting the position of overlapping geoms.

The way that the \code{a_position_*} functions work is slightly different from
the \code{a_geom_*} and \code{a_stat_*} functions, because a \code{a_position_*}
function actually "instantiates" the \code{a_Position*} object by creating a
descendant, and returns that.

Each of the \code{a_Position*} objects is a \code{\link{a_ggproto}} object,
descended from the top-level \code{a_Position}, and each implements the
following methods:

\itemize{
  \item \code{compute_layer(self, data, params, panel)} is called once
    per layer. \code{panel} is currently an internal data structure, so
    this method should not be overriden.

  \item \code{compute_panel(self, data, params, panel)} is called once per
    panel and should return a modified data frame.

    \code{data} is a data frame containing the variables named according
    to the aesthetics that they're mapped to. \code{scales} is a list
    containing the \code{x} and \code{y} scales. There functions are called
    before the facets are trained, so they are global scales, not local
    to the individual panels. \code{params} contains the parameters returned by
    \code{setup_params()}.
  \item \code{setup_params(data, params)}: called once for each layer.
     Used to setup defaults that need to complete dataset, and to inform
     the user of important choices. Should return list of parameters.
  \item \code{setup_data(data, params)}: called once for each layer,
     after \code{setp_params()}. Should return modified \code{data}.
     Default checks that required aesthetics are present.
}

And the following fields
\itemize{
  \item \code{required_aes}: a character vector giving the aesthetics
     that must be present for this position adjustment to work.
}
}

\section{a_Scales}{


All \code{a_scale_*} functions (like \code{a_scale_x_continuous}) return a
\code{a_Scale*} object (like \code{a_ScaleContinuous}). The \code{a_Scale*}
object represents a single scale.

Each of the \code{a_Scale*} objects is a \code{\link{a_ggproto}} object,
descended from the top-level \code{a_Scale}.
}

\seealso{
a_ggproto
}
\keyword{datasets}
\keyword{internal}
